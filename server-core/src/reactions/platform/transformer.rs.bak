// Copyright 2025 The Drasi Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Transformation logic for converting drasi-core QueryResult to Platform ChangeEvent

use super::types::{ResultChangeEvent, ResultEvent, UpdatePayload};
use crate::channels::QueryResult;
use anyhow::{anyhow, Result};
use serde_json::{Map, Value};

/// Transform a QueryResult into a ResultEvent
pub fn transform_query_result(
    query_result: QueryResult,
    sequence: i64,
) -> Result<ResultEvent> {
    let mut added_results = Vec::new();
    let mut updated_results = Vec::new();
    let mut deleted_results = Vec::new();

    // Parse the results array
    for result_item in query_result.results {
        let result_type = result_item
            .get("type")
            .and_then(|t| t.as_str())
            .ok_or_else(|| anyhow!("Missing 'type' field in result item"))?;

        match result_type {
            "add" | "ADD" => {
                // Extract data field for add operations
                let data = result_item
                    .get("data")
                    .ok_or_else(|| anyhow!("Missing 'data' field in add result"))?
                    .as_object()
                    .ok_or_else(|| anyhow!("'data' field must be an object"))?
                    .clone();
                added_results.push(data);
            }
            "update" | "UPDATE" => {
                // Extract before and after fields for update operations
                let before = result_item
                    .get("before")
                    .ok_or_else(|| anyhow!("Missing 'before' field in update result"))?
                    .as_object()
                    .ok_or_else(|| anyhow!("'before' field must be an object"))?
                    .clone();
                let after = result_item
                    .get("after")
                    .ok_or_else(|| anyhow!("Missing 'after' field in update result"))?
                    .as_object()
                    .ok_or_else(|| anyhow!("'after' field must be an object"))?
                    .clone();

                // Optional grouping keys
                let grouping_keys = result_item
                    .get("grouping_keys")
                    .and_then(|v| v.as_array())
                    .map(|arr| {
                        arr.iter()
                            .filter_map(|v| v.as_str().map(|s| s.to_string()))
                            .collect()
                    });

                updated_results.push(UpdatePayload {
                    before: Some(before),
                    after: Some(after),
                    grouping_keys,
                });
            }
            "delete" | "DELETE" => {
                // Extract data field for delete operations
                let data = result_item
                    .get("data")
                    .ok_or_else(|| anyhow!("Missing 'data' field in delete result"))?
                    .as_object()
                    .ok_or_else(|| anyhow!("'data' field must be an object"))?
                    .clone();
                deleted_results.push(data);
            }
            unknown => {
                log::warn!("Unknown result type: {}, skipping", unknown);
                continue;
            }
        }
    }

    // Convert timestamp to milliseconds since epoch
    let source_time_ms = query_result.timestamp.timestamp_millis() as u64;

    // Filter metadata - remove internal drasi-core fields that shouldn't be exposed
    let filtered_metadata: Map<String, Value> = query_result
        .metadata
        .into_iter()
        .filter(|(key, _)| {
            // Filter out internal query/source metadata
            !matches!(
                key.as_str(),
                "query" | "processed_by" | "source_id" | "result_count"
            )
        })
        .collect();

    // Convert metadata if present (filter out empty metadata)
    let metadata = if filtered_metadata.is_empty() {
        None
    } else {
        Some(filtered_metadata)
    };

    let change_event = ResultChangeEvent {
        query_id: query_result.query_id,
        sequence: sequence as u64,
        source_time_ms,
        added_results,
        updated_results,
        deleted_results,
        metadata,
    };

    Ok(ResultEvent::Change(change_event))
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;
    use std::collections::HashMap;

    #[test]
    fn test_transform_add_results() {
        let timestamp = chrono::DateTime::from_timestamp_millis(1609459200000).unwrap();
        let query_result = QueryResult {
            query_id: "test-query".to_string(),
            timestamp,
            results: vec![
                json!({
                    "type": "add",
                    "data": {"id": "1", "value": "test1"}
                }),
                json!({
                    "type": "add",
                    "data": {"id": "2", "value": "test2"}
                }),
            ],
            metadata: HashMap::new(),
            profiling: None,
            profiling: None,
        };

        let result = transform_query_result(query_result, 1).unwrap();

        match result {
            ResultEvent::Change(change) => {
                assert_eq!(change.query_id, "test-query");
                assert_eq!(change.sequence, 1);
                assert_eq!(change.source_time_ms, 1609459200000);
                assert_eq!(change.added_results.len(), 2);
                assert_eq!(change.updated_results.len(), 0);
                assert_eq!(change.deleted_results.len(), 0);
                assert_eq!(change.added_results[0]["id"], "1");
                assert_eq!(change.added_results[1]["id"], "2");
            }
            _ => panic!("Expected Change event"),
        }
    }

    #[test]
    fn test_transform_update_results() {
        let timestamp = chrono::DateTime::from_timestamp_millis(1609459200000).unwrap();
        let query_result = QueryResult {
            query_id: "test-query".to_string(),
            timestamp,
            results: vec![json!({
                "type": "update",
                "before": {"id": "1", "value": 10},
                "after": {"id": "1", "value": 20}
            })],
            metadata: HashMap::new(),
            profiling: None,
            profiling: None,
        };

        let result = transform_query_result(query_result, 2).unwrap();

        match result {
            ResultEvent::Change(change) => {
                assert_eq!(change.updated_results.len(), 1);
                assert_eq!(change.updated_results[0].before.as_ref().unwrap()["value"], 10);
                assert_eq!(change.updated_results[0].after.as_ref().unwrap()["value"], 20);
                assert_eq!(change.updated_results[0].grouping_keys, None);
            }
            _ => panic!("Expected Change event"),
        }
    }

    #[test]
    fn test_transform_update_with_grouping_keys() {
        let query_result = QueryResult {
            query_id: "test-query".to_string(),
            timestamp: chrono::DateTime::from_timestamp_millis(1609459200000).unwrap(),
            results: vec![json!({
                "type": "update",
                "before": {"id": "1", "value": 10},
                "after": {"id": "1", "value": 20},
                "grouping_keys": ["key1", "key2"]
            })],
            metadata: HashMap::new(),
            profiling: None,
            profiling: None,
        };

        let result = transform_query_result(query_result, 2).unwrap();

        match result {
            ResultEvent::Change(change) => {
                assert_eq!(change.updated_results.len(), 1);
                assert_eq!(
                    change.updated_results[0].grouping_keys,
                    Some(vec!["key1".to_string(), "key2".to_string()])
                );
            }
            _ => panic!("Expected Change event"),
        }
    }

    #[test]
    fn test_transform_delete_results() {
        let query_result = QueryResult {
            query_id: "test-query".to_string(),
            timestamp: chrono::DateTime::from_timestamp_millis(1609459200000).unwrap(),
            results: vec![json!({
                "type": "delete",
                "data": {"id": "1"}
            })],
            metadata: HashMap::new(),
            profiling: None,
            profiling: None,
        };

        let result = transform_query_result(query_result, 3).unwrap();

        match result {
            ResultEvent::Change(change) => {
                assert_eq!(change.deleted_results.len(), 1);
                assert_eq!(change.deleted_results[0]["id"], "1");
            }
            _ => panic!("Expected Change event"),
        }
    }

    #[test]
    fn test_transform_mixed_results() {
        let query_result = QueryResult {
            query_id: "test-query".to_string(),
            timestamp: chrono::DateTime::from_timestamp_millis(1609459200000).unwrap(),
            results: vec![
                json!({"type": "add", "data": {"id": "1"}}),
                json!({
                    "type": "update",
                    "before": {"id": "2", "value": 10},
                    "after": {"id": "2", "value": 20}
                }),
                json!({"type": "delete", "data": {"id": "3"}}),
            ],
            metadata: HashMap::new(),
            profiling: None,
            profiling: None,
        };

        let result = transform_query_result(query_result, 4).unwrap();

        match result {
            ResultEvent::Change(change) => {
                assert_eq!(change.added_results.len(), 1);
                assert_eq!(change.updated_results.len(), 1);
                assert_eq!(change.deleted_results.len(), 1);
            }
            _ => panic!("Expected Change event"),
        }
    }

    #[test]
    fn test_transform_with_metadata() {
        let mut metadata = HashMap::new();
        metadata.insert("tracking".to_string(), json!({"timing": 100}));
        metadata.insert("query".to_string(), json!({"execution_time": 50})); // Will be filtered out
        metadata.insert("source_id".to_string(), json!("test-source")); // Will be filtered out

        let query_result = QueryResult {
            query_id: "test-query".to_string(),
            timestamp: chrono::DateTime::from_timestamp_millis(1609459200000).unwrap(),
            results: vec![json!({"type": "add", "data": {"id": "1"}})],
            metadata,
        };

        let result = transform_query_result(query_result, 5).unwrap();

        match result {
            ResultEvent::Change(change) => {
                assert!(change.metadata.is_some());
                let meta = change.metadata.unwrap();
                // Only non-filtered metadata should remain
                assert!(meta.contains_key("tracking"));
                assert!(!meta.contains_key("query")); // Should be filtered
                assert!(!meta.contains_key("source_id")); // Should be filtered
            }
            _ => panic!("Expected Change event"),
        }
    }

    #[test]
    fn test_transform_missing_type_field() {
        let query_result = QueryResult {
            query_id: "test-query".to_string(),
            timestamp: chrono::DateTime::from_timestamp_millis(1609459200000).unwrap(),
            results: vec![json!({"data": {"id": "1"}})], // Missing "type" field
            metadata: HashMap::new(),
            profiling: None,
            profiling: None,
        };

        let result = transform_query_result(query_result, 1);
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Missing 'type' field"));
    }

    #[test]
    fn test_transform_missing_data_field_in_add() {
        let query_result = QueryResult {
            query_id: "test-query".to_string(),
            timestamp: chrono::DateTime::from_timestamp_millis(1609459200000).unwrap(),
            results: vec![json!({"type": "add"})], // Missing "data" field
            metadata: HashMap::new(),
            profiling: None,
            profiling: None,
        };

        let result = transform_query_result(query_result, 1);
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Missing 'data' field"));
    }

    #[test]
    fn test_transform_missing_before_field_in_update() {
        let query_result = QueryResult {
            query_id: "test-query".to_string(),
            timestamp: chrono::DateTime::from_timestamp_millis(1609459200000).unwrap(),
            results: vec![json!({
                "type": "update",
                "after": {"id": "1", "value": 20}
            })],
            metadata: HashMap::new(),
            profiling: None,
            profiling: None,
        };

        let result = transform_query_result(query_result, 1);
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Missing 'before' field"));
    }

    #[test]
    fn test_transform_unknown_type_skipped() {
        let query_result = QueryResult {
            query_id: "test-query".to_string(),
            timestamp: chrono::DateTime::from_timestamp_millis(1609459200000).unwrap(),
            results: vec![
                json!({"type": "add", "data": {"id": "1"}}),
                json!({"type": "unknown", "data": {"id": "2"}}), // Unknown type
                json!({"type": "delete", "data": {"id": "3"}}),
            ],
            metadata: HashMap::new(),
            profiling: None,
            profiling: None,
        };

        let result = transform_query_result(query_result, 1).unwrap();

        match result {
            ResultEvent::Change(change) => {
                assert_eq!(change.added_results.len(), 1);
                assert_eq!(change.deleted_results.len(), 1);
                // Unknown type was skipped
            }
            _ => panic!("Expected Change event"),
        }
    }

    #[test]
    fn test_transform_empty_metadata_filtered() {
        let query_result = QueryResult {
            query_id: "test-query".to_string(),
            timestamp: chrono::DateTime::from_timestamp_millis(1609459200000).unwrap(),
            results: vec![json!({"type": "add", "data": {"id": "1"}})],
            metadata: HashMap::new(), // Empty metadata
        };

        let result = transform_query_result(query_result, 1).unwrap();

        match result {
            ResultEvent::Change(change) => {
                assert!(change.metadata.is_none());
            }
            _ => panic!("Expected Change event"),
        }
    }
}
